from pathlib import Path
path = Path("server/services/openRouterService.ts")
text = path.read_text(encoding="utf-8")
start = text.find("  private generateRuleBasedSummary")
if start == -1:
    raise SystemExit('start not found')
end = text.find("  /**\n   * Check if the service is properly configured", start)
if end == -1:
    raise SystemExit('end not found')
replacement = "  private generateRuleBasedSummary(fplContext: any): string | null {\n    const analysis = fplContext?.analysisData;\n    if (!analysis) {\n      return null;\n    }\n\n    const lines: string[] = [];\n    const teamName = analysis.teamName || (analysis.teamId ? `Team ${analysis.teamId}` : 'your squad');\n    lines.push(`Looking at your current squad data for ${teamName}.`);\n\n    const budget = analysis.budget ?? fplContext?.squadData;\n    if (budget) {\n      const budgetParts: string[] = [];\n      if (typeof budget.teamValue === 'number') {\n        budgetParts.push(`squad value £${budget.teamValue.toFixed(1)}m`);\n      }\n      if (typeof budget.bank === 'number') {\n        budgetParts.push(`bank £${budget.bank.toFixed(1)}m`);\n      }\n      if (typeof budget.freeTransfers === 'number') {\n        budgetParts.push(`${budget.freeTransfers} free transfers`);\n      }\n      if (budgetParts.length) {\n        lines.push(`Budget overview: ${budgetParts.join(', ')}.`);\n      }\n    }\n\n    const players = Array.isArray(analysis.players) ? analysis.players : [];\n    if (players.length) {\n      const starters = players.filter((p: any) => p.isStarter);\n      const metric = (p: any) => (typeof p.expectedPoints === 'number' ? p.expectedPoints : (typeof p.points === 'number' ? p.points : 0));\n      const topStarters = [...starters].sort((a: any, b: any) => metric(b) - metric(a)).slice(0, 3);\n      if (topStarters.length) {\n        const descriptions = topStarters.map((p: any) => {\n          const label = typeof p.expectedPoints === 'number'\n            ? `${p.expectedPoints.toFixed(1)} expected pts`\n            : `${p.points ?? 0} pts`;\n          return `${p.name} (${label})`;\n        });\n        lines.push(`Key starters: ${descriptions.join(', ')}.`);\n      }\n\n      const benchCandidates = players.filter((p: any) => p.isBench).slice(0, 2);\n      if (benchCandidates.length) {\n        const benchDescriptions = benchCandidates.map((p: any) => {\n          const value = typeof p.expectedPoints === 'number' ? p.expectedPoints.toFixed(1) : `${p.points ?? 0}`;\n          return `${p.name} (${value} pts)`;\n        });\n        lines.push(`Bench watch: ${benchDescriptions.join(', ')}.`);\n      }\n    }\n\n    const gameweeks = Array.isArray(analysis.gameweeks) ? analysis.gameweeks : [];\n    if (gameweeks.length) {\n      const upcoming = gameweeks.slice(0, 2).map((gw: any) => {\n        if (Array.isArray(gw.fixtures) && gw.fixtures.length) {\n          const highlights = gw.fixtures.slice(0, 2).map((f: any) => {\n            const fdrValue = typeof f.fdr === 'number' ? Math.round(f.fdr) : Math.round(gw.averageFDR ?? 3);\n            return `${f.playerName} vs ${f.opponent} (${f.isHome ? 'H' : 'A'}, FDR ${fdrValue})`;\n          });\n          return `GW${gw.gameweek}: ${highlights.join('; ')}`;\n        }\n        if (typeof gw.averageFDR === 'number') {\n          return `GW${gw.gameweek}: average FDR ${gw.averageFDR.toFixed(1)}`;\n        }\n        return null;\n      }).filter((value): value is string => Boolean(value));\n      if (upcoming.length) {\n        lines.push(`Upcoming fixtures: ${upcoming.join(' | ')}.`);\n      }\n    }\n\n    const recommendations = Array.isArray(analysis.recommendations) ? analysis.recommendations : [];\n    if (recommendations.length) {\n      const rec = recommendations[0];\n      const detail = Array.isArray(rec.reasoning) && rec.reasoning.length\n        ? ` (${rec.reasoning.slice(0, 2).join('; ')})`\n        : '';\n      lines.push(`Chip outlook: consider ${rec.chipType} in GW${rec.gameweek}${detail}.`);\n    }\n\n    const summary = lines.join('\\n\\n');\n    return summary ? this.sanitizeFinalContent(summary) : null;\n  }\n\n"
text = text[:start] + replacement + text[end:]
path.write_text(text, encoding="utf-8")
